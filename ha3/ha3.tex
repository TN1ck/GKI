\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[german]{babel}
\setlength{\parindent}{0cm}
\usepackage{setspace}
\usepackage{mathpazo}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wasysym}
\usepackage{booktabs}
\usepackage{verbatim}
\usepackage{ulem}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{ulem}
\usepackage{stmaryrd }
\usepackage[a4paper,
left=1.8cm, right=1.8cm,
top=2.0cm, bottom=2.0cm]{geometry}
\usepackage{tabularx}
\usepackage{tikz}
\usetikzlibrary{trees,petri,decorations,arrows,automata,shapes,shadows,positioning,plotmarks}

\lstdefinelanguage{clojure}%
{morekeywords={*,*1,*2,*3,*agent*,*allow-unresolved-vars*,*assert*,*clojure-version*,*command-line-args*,%
*compile-files*,*compile-path*,*e,*err*,*file*,*flush-on-newline*,*in*,*macro-meta*,%
*math-context*,*ns*,*out*,*print-dup*,*print-length*,*print-level*,*print-meta*,*print-readably*,%
*read-eval*,*source-path*,*use-context-classloader*,*warn-on-reflection*,+,-,->,->>,..,/,:else,%
<,<=,=,==,>,>=,@,accessor,aclone,add-classpath,add-watch,agent,agent-errors,aget,alength,alias,%
all-ns,alter,alter-meta!,alter-var-root,amap,ancestors,and,apply,areduce,array-map,aset,%
aset-boolean,aset-byte,aset-char,aset-double,aset-float,aset-int,aset-long,aset-short,assert,%
assoc,assoc!,assoc-in,associative?,atom,await,await-for,await1,bases,bean,bigdec,bigint,binding,%
bit-and,bit-and-not,bit-clear,bit-flip,bit-not,bit-or,bit-set,bit-shift-left,bit-shift-right,%
bit-test,bit-xor,boolean,boolean-array,booleans,bound-fn,bound-fn*,butlast,byte,byte-array,%
bytes,cast,char,char-array,char-escape-string,char-name-string,char?,chars,chunk,chunk-append,%
chunk-buffer,chunk-cons,chunk-first,chunk-next,chunk-rest,chunked-seq?,class,class?,%
clear-agent-errors,clojure-version,coll?,comment,commute,comp,comparator,compare,compare-and-set!,%
compile,complement,concat,cond,condp,conj,conj!,cons,constantly,construct-proxy,contains?,count,%
counted?,create-ns,create-struct,cycle,dec,decimal?,declare,def,definline,defmacro,defmethod,%
defmulti,defn,defn-,defonce,defprotocol,defstruct,deftype,delay,delay?,deliver,deref,derive,%
descendants,destructure,disj,disj!,dissoc,dissoc!,distinct,distinct?,do,do-template,doall,doc,%
dorun,doseq,dosync,dotimes,doto,double,double-array,doubles,drop,drop-last,drop-while,empty,empty?,%
ensure,enumeration-seq,eval,even?,every?,false,false?,ffirst,file-seq,filter,finally,find,find-doc,%
find-ns,find-var,first,float,float-array,float?,floats,flush,fn,fn?,fnext,for,force,format,future,%
future-call,future-cancel,future-cancelled?,future-done?,future?,gen-class,gen-interface,gensym,%
get,get-in,get-method,get-proxy-class,get-thread-bindings,get-validator,hash,hash-map,hash-set,%
identical?,identity,if,if-let,if-not,ifn?,import,in-ns,inc,init-proxy,instance?,int,int-array,%
integer?,interleave,intern,interpose,into,into-array,ints,io!,isa?,iterate,iterator-seq,juxt,%
key,keys,keyword,keyword?,last,lazy-cat,lazy-seq,let,letfn,line-seq,list,list*,list?,load,load-file,%
load-reader,load-string,loaded-libs,locking,long,long-array,longs,loop,macroexpand,macroexpand-1,%
make-array,make-hierarchy,map,map?,mapcat,max,max-key,memfn,memoize,merge,merge-with,meta,%
method-sig,methods,min,min-key,mod,monitor-enter,monitor-exit,name,namespace,neg?,new,newline,%
next,nfirst,nil,nil?,nnext,not,not-any?,not-empty,not-every?,not=,ns,ns-aliases,ns-imports,%
ns-interns,ns-map,ns-name,ns-publics,ns-refers,ns-resolve,ns-unalias,ns-unmap,nth,nthnext,num,%
number?,odd?,or,parents,partial,partition,pcalls,peek,persistent!,pmap,pop,pop!,pop-thread-bindings,%
pos?,pr,pr-str,prefer-method,prefers,primitives-classnames,print,print-ctor,print-doc,print-dup,%
print-method,print-namespace-doc,print-simple,print-special-doc,print-str,printf,println,println-str,%
prn,prn-str,promise,proxy,proxy-call-with-super,proxy-mappings,proxy-name,proxy-super,%
push-thread-bindings,pvalues,quot,rand,rand-int,range,ratio?,rational?,rationalize,re-find,%
re-groups,re-matcher,re-matches,re-pattern,re-seq,read,read-line,read-string,recur,reduce,ref,%
ref-history-count,ref-max-history,ref-min-history,ref-set,refer,refer-clojure,reify,%
release-pending-sends,rem,remove,remove-method,remove-ns,remove-watch,repeat,repeatedly,%
replace,replicate,require,reset!,reset-meta!,resolve,rest,resultset-seq,reverse,reversible?,%
rseq,rsubseq,second,select-keys,send,send-off,seq,seq?,seque,sequence,sequential?,set,set!,%
set-validator!,set?,short,short-array,shorts,shutdown-agents,slurp,some,sort,sort-by,sorted-map,%
sorted-map-by,sorted-set,sorted-set-by,sorted?,special-form-anchor,special-symbol?,split-at,%
split-with,str,stream?,string?,struct,struct-map,subs,subseq,subvec,supers,swap!,symbol,symbol?,%
sync,syntax-symbol-anchor,take,take-last,take-nth,take-while,test,the-ns,throw,time,to-array,%
to-array-2d,trampoline,transient,tree-seq,true,true?,try,type,unchecked-add,unchecked-dec,%
unchecked-divide,unchecked-inc,unchecked-multiply,unchecked-negate,unchecked-remainder,%
unchecked-subtract,underive,unquote,unquote-splicing,update-in,update-proxy,use,val,vals,%
var,var-get,var-set,var?,vary-meta,vec,vector,vector?,when,when-first,when-let,when-not,%
while,with-bindings,with-bindings*,with-in-str,with-loading-context,with-local-vars,%
with-meta,with-open,with-out-str,with-precision,xml-seq,zero?,zipmap
},%
   sensitive,% ???
   alsodigit=-,%
   morecomment=[l];,%
   morestring=[b]"%
  }[keywords,comments,strings]%

\lstset{language=Clojure,showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange}}

\newcommand{\rf}{\right\rfloor}
\newcommand{\lf}{\left\lfloor}
\newcommand{\tabspace}{15cm}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\begin{document}
\begin{center}
\Large{Grundlagen der künstlichen Intelligenz: Hausaufgabe 3} \\
\end{center}
\begin{tabbing}
Tom Nick \hspace{2cm}\= - 340528\\
Niklas Gebauer \> - 340942 \\
Leonard Witte \> - 341457 \\
Johannes Herrmann \> - 341091\\
\end{tabbing}

\section*{Aufgabe 1}

\begin{enumerate}[~~a)]
    \item $\forall x (Stack(x) \Rightarrow ((\exists y (Block(y) \land in(y,x))) \land (\forall y(in(y,x) \Rightarrow Block(y)))))$

    \item $\forall x (Stack(x) \Rightarrow \exists y ((Block(y) \land in(y,x) \land on(y,T)) \land \forall z ((Block(z) \land in(z,x) \land on(z,T)) \Rightarrow z=y)))$

    \item $\forall x (Block(x) \Rightarrow ( (\lnot\exists y ((Block(y) \land on(x,y)) \land on(x,T)) \lor (\exists y (Block(y) \land on(x,y)) \land \lnot on(x,T) )))$

    \item $\forall x (Block(x) \land \lnot \exists y (Block(y) \land on(y,x))) \Rightarrow top(x)$

    \item $\forall x \forall y (Block(x) \land Block(y) \land ((on(x,y) \land \lnot\exists z (Stack(z) \land in(x,z) \land on(z,y) \land top(x))) \lor (\lnot on(x,y) \land \exists z (Stack(z) \land in(x,z) \land on(z,y) \land top(x)))) \Rightarrow over(x,y))$

    \item $\forall x ((Block(x) \land rot(x)) \Rightarrow in (x,1))$

    \item $\forall x (in(x,2) \Rightarrow (Block(x) \land blau(x)))$
\end{enumerate}

\section*{Aufgabe 2}

\begin{enumerate}
    \item Implikationen entfernen, denn in einer KNF kommen lediglich Disjunktionen und Konjunktionen vor. Wir verwenden die Auflösung für Implikationen ($a \Rightarrow b \equiv \lnot a \lor b$):\\
    $(\forall x)(\lnot P(x) \lor ((\forall y)(\lnot P(y) \lor P(f(x,y))) \land \lnot (\forall y)(\lnot Q(x,y) \lor P(y))))$

    \item Negationen nach innen bringen, um nur Literale zu haben. Wir verwenden die Regel von De'Morgan:\\
    $(\forall x)(\lnot P(x) \lor ((\forall y)(\lnot P(y) \lor p(f(x,y))) \land (\exists y)(Q(x,y) \land \lnot P(y))))$

    \item Unabhängige Variablen (solche, die im Bindungsbereich verschiedener Quantoren liegen) umbenennen, um Eindeutigkeit herzustellen, damit später ohne Probleme Quantoren nach außen gezogen werden können:\\
    $(\forall x)(\lnot P(x) \lor ((\forall y)(\lnot P(y) \lor P(f(x,y))) \land (\exists z)(Q(x,z) \land \lnot P(z))))$

    \item Um eine KNF zu erhalten, müssen wir die Quantoren entfernen. Zuerst bringen wir sie dafür nach außen:\\
    $(\forall x)(\forall y)(\exists z)(\lnot P(x) \lor ((\lnot P(y) \lor P(f(x,y))) \land (Q(x,z) \land \lnot P(z))))$

    \item Quantoren entfernen, indem wir Existenzquantoren durch Konstanten oder n-stellige Funktionen ersetzen, wobei n die Anzahl der Allquantoren ist, in deren Scope sich der Existenzquantor befindet. Danach können die Allquantoren einfach weggelassen werden, da dann alle Variablen implizit allquantisiert sind. Wir erhalten eine erfüllbarkeitsäquivalente skolemisierte Formel. Wir führen also für z eine 2-stellige Funktion g(x,y) ein:\\
    $\lnot P(x) \lor ((\lnot P(y) \lor P(f(x,y))) \land (Q(x,g(x,y)) \land \lnot P(g(x,y))))$

    \item Nach KNF umformen (in diesem Fall durch iterative Anwendung des Distributivgesetzes):\\
    $(\lnot P(x) \lor \lnot P(y) \lor P(f(x,y))) \land (\lnot P(x) \lor Q(x,g(x,y))) \land (\lnot P(x) \lor \lnot P(g(x,y)))$\\
    In Mengenschreibweise:\\
    $\{\{\lnot P(x), \lnot P(y), P(f(x,y))\}, \{\lnot P(x),Q(x,g(x,y))\},\{\lnot P(x),\lnot P(g(x,y))\}\}$ \\
    Die Klausel sollten jeweils paarweise Disjunkte Variablen enthalten, damit beispielsweise die Resolution einfach durchgeführt werden kann. Dafür kann man die Variablen umbenennen:\\
    $\{\{\lnot P(x), \lnot P(y), P(f(x,y))\}, \{\lnot P(a),Q(a,g(a,b))\},\{\lnot P(c),\lnot P(g(c,d))\}\}$
\end{enumerate}

\section*{Aufgabe 3}

\begin{enumerate}[~~a)]
    \item

    \item

    \item

    \item
\end{enumerate}

\section*{Aufgabe 4}

\begin{enumerate}[~~a)]
    \item

    \item

    \item

    \item

    \item
\end{enumerate}

\section*{Aufgabe 5}

\end{document}
