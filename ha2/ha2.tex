\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[german]{babel}
\setlength{\parindent}{0cm}
\usepackage{setspace}
\usepackage{mathpazo}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wasysym} 
\usepackage{booktabs}
\usepackage{verbatim}
\usepackage{ulem}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{ulem}
\usepackage{stmaryrd }
\usepackage[a4paper,
left=1.8cm, right=1.8cm,
top=2.0cm, bottom=2.0cm]{geometry}
\usepackage{tabularx}
\usepackage{tikz}
\usetikzlibrary{trees,petri,decorations,arrows,automata,shapes,shadows,positioning,plotmarks}

\lstdefinelanguage{clojure}%
{morekeywords={*,*1,*2,*3,*agent*,*allow-unresolved-vars*,*assert*,*clojure-version*,*command-line-args*,%
*compile-files*,*compile-path*,*e,*err*,*file*,*flush-on-newline*,*in*,*macro-meta*,%
*math-context*,*ns*,*out*,*print-dup*,*print-length*,*print-level*,*print-meta*,*print-readably*,%
*read-eval*,*source-path*,*use-context-classloader*,*warn-on-reflection*,+,-,->,->>,..,/,:else,%
<,<=,=,==,>,>=,@,accessor,aclone,add-classpath,add-watch,agent,agent-errors,aget,alength,alias,%
all-ns,alter,alter-meta!,alter-var-root,amap,ancestors,and,apply,areduce,array-map,aset,%
aset-boolean,aset-byte,aset-char,aset-double,aset-float,aset-int,aset-long,aset-short,assert,%
assoc,assoc!,assoc-in,associative?,atom,await,await-for,await1,bases,bean,bigdec,bigint,binding,%
bit-and,bit-and-not,bit-clear,bit-flip,bit-not,bit-or,bit-set,bit-shift-left,bit-shift-right,%
bit-test,bit-xor,boolean,boolean-array,booleans,bound-fn,bound-fn*,butlast,byte,byte-array,%
bytes,cast,char,char-array,char-escape-string,char-name-string,char?,chars,chunk,chunk-append,%
chunk-buffer,chunk-cons,chunk-first,chunk-next,chunk-rest,chunked-seq?,class,class?,%
clear-agent-errors,clojure-version,coll?,comment,commute,comp,comparator,compare,compare-and-set!,%
compile,complement,concat,cond,condp,conj,conj!,cons,constantly,construct-proxy,contains?,count,%
counted?,create-ns,create-struct,cycle,dec,decimal?,declare,def,definline,defmacro,defmethod,%
defmulti,defn,defn-,defonce,defprotocol,defstruct,deftype,delay,delay?,deliver,deref,derive,%
descendants,destructure,disj,disj!,dissoc,dissoc!,distinct,distinct?,do,do-template,doall,doc,%
dorun,doseq,dosync,dotimes,doto,double,double-array,doubles,drop,drop-last,drop-while,empty,empty?,%
ensure,enumeration-seq,eval,even?,every?,false,false?,ffirst,file-seq,filter,finally,find,find-doc,%
find-ns,find-var,first,float,float-array,float?,floats,flush,fn,fn?,fnext,for,force,format,future,%
future-call,future-cancel,future-cancelled?,future-done?,future?,gen-class,gen-interface,gensym,%
get,get-in,get-method,get-proxy-class,get-thread-bindings,get-validator,hash,hash-map,hash-set,%
identical?,identity,if,if-let,if-not,ifn?,import,in-ns,inc,init-proxy,instance?,int,int-array,%
integer?,interleave,intern,interpose,into,into-array,ints,io!,isa?,iterate,iterator-seq,juxt,%
key,keys,keyword,keyword?,last,lazy-cat,lazy-seq,let,letfn,line-seq,list,list*,list?,load,load-file,%
load-reader,load-string,loaded-libs,locking,long,long-array,longs,loop,macroexpand,macroexpand-1,%
make-array,make-hierarchy,map,map?,mapcat,max,max-key,memfn,memoize,merge,merge-with,meta,%
method-sig,methods,min,min-key,mod,monitor-enter,monitor-exit,name,namespace,neg?,new,newline,%
next,nfirst,nil,nil?,nnext,not,not-any?,not-empty,not-every?,not=,ns,ns-aliases,ns-imports,%
ns-interns,ns-map,ns-name,ns-publics,ns-refers,ns-resolve,ns-unalias,ns-unmap,nth,nthnext,num,%
number?,odd?,or,parents,partial,partition,pcalls,peek,persistent!,pmap,pop,pop!,pop-thread-bindings,%
pos?,pr,pr-str,prefer-method,prefers,primitives-classnames,print,print-ctor,print-doc,print-dup,%
print-method,print-namespace-doc,print-simple,print-special-doc,print-str,printf,println,println-str,%
prn,prn-str,promise,proxy,proxy-call-with-super,proxy-mappings,proxy-name,proxy-super,%
push-thread-bindings,pvalues,quot,rand,rand-int,range,ratio?,rational?,rationalize,re-find,%
re-groups,re-matcher,re-matches,re-pattern,re-seq,read,read-line,read-string,recur,reduce,ref,%
ref-history-count,ref-max-history,ref-min-history,ref-set,refer,refer-clojure,reify,%
release-pending-sends,rem,remove,remove-method,remove-ns,remove-watch,repeat,repeatedly,%
replace,replicate,require,reset!,reset-meta!,resolve,rest,resultset-seq,reverse,reversible?,%
rseq,rsubseq,second,select-keys,send,send-off,seq,seq?,seque,sequence,sequential?,set,set!,%
set-validator!,set?,short,short-array,shorts,shutdown-agents,slurp,some,sort,sort-by,sorted-map,%
sorted-map-by,sorted-set,sorted-set-by,sorted?,special-form-anchor,special-symbol?,split-at,%
split-with,str,stream?,string?,struct,struct-map,subs,subseq,subvec,supers,swap!,symbol,symbol?,%
sync,syntax-symbol-anchor,take,take-last,take-nth,take-while,test,the-ns,throw,time,to-array,%
to-array-2d,trampoline,transient,tree-seq,true,true?,try,type,unchecked-add,unchecked-dec,%
unchecked-divide,unchecked-inc,unchecked-multiply,unchecked-negate,unchecked-remainder,%
unchecked-subtract,underive,unquote,unquote-splicing,update-in,update-proxy,use,val,vals,%
var,var-get,var-set,var?,vary-meta,vec,vector,vector?,when,when-first,when-let,when-not,%
while,with-bindings,with-bindings*,with-in-str,with-loading-context,with-local-vars,%
with-meta,with-open,with-out-str,with-precision,xml-seq,zero?,zipmap
},%
   sensitive,% ???
   alsodigit=-,%
   morecomment=[l];,%
   morestring=[b]"%
  }[keywords,comments,strings]%

\lstset{language=Clojure,showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange}}

\newcommand{\rf}{\right\rfloor}
\newcommand{\lf}{\left\lfloor}
\newcommand{\tabspace}{15cm}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\begin{document}
\begin{center}
\Large{Grundlagen der künstlichen Intelligenz: Hausaufgabe 2} \\
\end{center}
\begin{tabbing}
Tom Nick \hspace{2cm}\= - 340528\\
Niklas Gebauer \> - 340942 \\
Leonard Witte \> - 341457 \\
Johannes Herrmann \> - xxxxxx\\
\end{tabbing}

\section*{Aufgabe 1}



\section*{Aufgabe 2}
\begin{enumerate}[~~a)]

\item
Das Zuordnungsproblem in 2-konsistentem Zustand: \\
\includegraphics[scale=0.7]{Aufgabe2a}

\item
Wir wählen für den nächsten Schritt die MRV-Heuristik, da wir Variablen mit einem kleinen Wertebereich möglichst schnell belegen wollen, um früh auf mögliche Fehler zu stoßen. Allerdings ergibt es nach dem Herstellen des 2-konsistenten Zustands keinen Sinn, Variablen auszuwählen, die einen ein-elementigen Wertebereich haben, denn aufgrund der 2-Konsistenz kann keine zukünftige Belegung anderer Variablen dazu führen, dass die Ein-elementigen nicht mehr belegt werden könnten. Daher können sie später belegt werden, wenn der Rest des Zuordnungsproblems gelöst ist. \\
Da wir im nächsten Schritt Forward Checking verwenden werden, ist es sinnvoll MCV als Tie-Breaker zu verwenden, um eine Variable zu wählen, die den Wertebereich von möglichst vielen anderen Variablen betrifft, falls es mehrere Variablen gibt, nachdem die MRV-Heuristik angewendet wurde.\\
Für unser Problem sind die Wertebereiche der Variablen $(2,2), (3,2), (4,3),$ und $(4.4)$ im 2-konsistenten Zustand alle gleich klein (zwei Elemente). \\
Der Tie-Breaker MCV liefert uns nun $(2,2)$ und $(3,2)$ da diese jeweils Constraints zu noch 5 unbelegt Variablen haben (die anderen beiden kandidaten jeweils nur 4). Wir wählen eine dieser Variablen zufällig für unseren nächsten Schritt.\\
\item
Sei die von uns zufällig gewählte Variable der beiden oben genannten Kandidaten $(2,2)$. Dann belegen wir diese mit dem Wert $1$ und erhalten so mittels Forward-Checking folgende eingeschränkte Wertebereiche: \\
$(2,1) = \{2,4\} \\
(2,3) = \{ 3,4\} \\
(3,2) = \{2\}$\\
Alle anderen Wertebereiche bleiben unverändert.
\end{enumerate}

\section*{Aufgabe 3}

\begin{enumerate}[~~a)]

\item
Anzahl der Konflikte zu Beginn (alle Knoten weiss): 10 \\
\\
\begin{tabular}{|c|c|c|c|}
\hline
Schritt & Knoten & Farbe & resultierende Konflikte  \\ \hline
1. & B & Grau & 6 \\ \hline
2. & A & Schwarz & 4 \\ \hline
3. & C & Schwarz & 2 \\ \hline
4. & F & Grau & 1 \\ \hline
\end{tabular} \\ \\
Ergebnis: Der Algorithmus terminiert, ohne eine Lösung (vollständige und konsistente Belegung) zu finden.

\item
Wir ändern die Tie-Break-Regel nun so, dass wir den lexikographisch größten Knoten wählen, wenn die Anzahl der resultierenden Konflikte gleich ist. Somit würde der Algorithmus wie folgt ablaufen: \\
\\
\begin{tabular}{|c|c|c|c|}
\hline
Schritt & Knoten & Farbe & resultierende Konflikte  \\ \hline
1. & B & Grau & 6 \\ \hline
2. & G & Grau & 4 \\ \hline
3. & E & Schwarz & 2 \\ \hline
4. & A & Schwarz & 0 \\ \hline
\end{tabular} \\ \\
Ergebnis: Wir finden eine Lösung für das CSP!

\end{enumerate}

\section*{Aufgabe 4}

\section*{Aufgabe 5}
\begin{enumerate}[~~a)]

\item Spielbaum mit allen Minimax-Werten an den Knoten: \\
\includegraphics[scale=1]{Aufgabe5} 

\item Die Zweige, die durch Cut-Offs entfernt würden, sind im obigen Bild markiert.

\end{enumerate}

\end{document}